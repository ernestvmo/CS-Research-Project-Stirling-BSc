/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package ui;

import java.awt.*;
import java.math.BigDecimal;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JList;
import javax.swing.JScrollPane;
import javax.swing.ListModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import Optimisation.Individual;

import javax.swing.AbstractListModel;

/**
 *
 * @author cvaeib
 */
public class VisualisePopulation_E extends JFrame
{
	/** generated by eclipse */
	private static final long serialVersionUID = 7605105046723619314L;

//	public static void main(String[] args)
//	{
//		 VisualisePopulation_E f = new VisualisePopulation_E();
//		 f.updatePopulation(null);
//	}

	private boolean fixedMinMax;
	private double minFitness1;
	private double maxFitness1;
	private double minFitness2;
	private double maxFitness2;
	private Individual[] population;
	private JList list;

	public VisualisePopulation_E()
	{
		this(0, 1, 0, 1);
		this.fixedMinMax = false;
		
		JPanel panelGraph = new JPanel();
		getContentPane().add(panelGraph, BorderLayout.CENTER);
		
		JScrollPane scrollPane = new JScrollPane();
		scrollPane.setSize(new Dimension(200, 0));
		scrollPane.setPreferredSize(new Dimension(200, 2));
		getContentPane().add(scrollPane, BorderLayout.EAST);
		
		list = new JList();
		list.addListSelectionListener(new ListSelectionListener()
		{
			@Override
			public void valueChanged(ListSelectionEvent e)
			{
				// TODO Auto-generated method stub
				if (list.getSelectedIndex() != -1)
				{
					new FacadeUI(population[list.getSelectedIndex()]);
				}
			}
		});
		scrollPane.setViewportView(list);
	}

	public VisualisePopulation_E(double minFitness1, double maxFitness1,
			double minFitness2, double maxFitness2)
	{
		this.fixedMinMax = true;
		this.minFitness1 = minFitness1;
		this.maxFitness1 = maxFitness1;
		this.minFitness2 = minFitness2;
		this.maxFitness2 = maxFitness2;
		this.setTitle("Visualise Population");
		this.setSize(1100, 650);
		this.setVisible(true);
		this.population = null;
		this.setDefaultCloseOperation(EXIT_ON_CLOSE);
		this.setResizable(false);
	}

	public void updatePopulation(Individual[] pop)
	{
		if (!fixedMinMax)
		{
			System.out.println("HERE");
			double min1 = Double.POSITIVE_INFINITY;
			double min2 = Double.POSITIVE_INFINITY;
			double max1 = Double.NEGATIVE_INFINITY;
			double max2 = Double.NEGATIVE_INFINITY;
			
//			min1 = 40000;
//			max1 = 48000;
			
			for (Individual i : pop)
			{
				if (i.getFitness1() < min1)
				{
					min1 = i.getFitness1();
				} 
				if (i.getFitness1() > max1)
				{
					max1 = i.getFitness1();
				}
			}
			
			min2 = 12000;
			max2 = 42000;

			// add a bit of padding
			double pad1 = (max1 - min1) * 0.2;
			double pad2 = (max2 - min2) * 0.2;

			this.minFitness1 = min1 - pad1;
			this.maxFitness1 = max1 + pad1;
			this.minFitness2 = min2 - pad2;
			this.maxFitness2 = max2 + pad2;
		}

		this.population = pop;
		// this.invalidate();
		// this.validate();
		this.repaint();
	}

	public void paint(Graphics g)
	{
		Graphics2D g2 = (Graphics2D) g;
		g2.setColor(Color.white);
		Rectangle bounds = this.getBounds();// g2.getClipBounds();
		bounds.setLocation(0, 0); // okay, we don't want to include the window's
									// coords for internal drawing!
		g2.fillRect(bounds.x, bounds.y, bounds.width - 200, bounds.height);

		// draw axes
		int axisOffset = 50;
		g2.setColor(Color.gray);
		int xAxisYPos = bounds.y + (bounds.height - axisOffset);
		int yAxisXPos = bounds.x + axisOffset;
		g2.drawLine(bounds.x, xAxisYPos, bounds.x + bounds.width, xAxisYPos); // x-axis
		g2.drawLine(yAxisXPos, bounds.y, yAxisXPos, bounds.height); // y-axis

		// trim the bounds to omit the axes (y coord is same as that's at top of
		// window)
		
		Rectangle trimmedBounds = new Rectangle(bounds.x + axisOffset, bounds.y, bounds.width - (axisOffset + 200), bounds.height - axisOffset);
		
		// add tic marks
		int textHeight = 20;
		int textWidth = 40;

		// points on axes (tics)
		int numXTics = 10;
		int numYTics = 10;
		int ticSize = 3;
		// NB- after this we pretend there is an extra tic at the extremes of
		// each of the axes, but don't show it as it'd be clipped
		
		double xTicInterval = (maxFitness1 - minFitness1) / (numXTics);
//		System.out.println("xTicInterval "  + xTicInterval);
		
//		System.out.println(maxFitness2 + "  " + minFitness2);
		
		double yTicInterval = (maxFitness2 - minFitness2) / (numYTics);
//		System.out.println("yTicInterval ss "  + yTicInterval);
		
		int xTicCoordStep = (trimmedBounds.width ) / (numXTics);
		int yTicCoordStep = (bounds.height - axisOffset) / (numYTics);
		
//		System.out.println(yTicCoordStep);

		double nextTicVal = minFitness1;
		for (int j = 0; j < numXTics; j++)
		{
//			int ticX = (bounds.x + axisOffset) + (xTicCoordStep * j);
			int ticX = trimmedBounds.x + (xTicCoordStep * j);
			
			g2.drawLine(ticX, xAxisYPos + ticSize, ticX, xAxisYPos - ticSize);
			
			g2.drawString(Double.toString(roundDouble(nextTicVal, 2)), ticX, xAxisYPos + textHeight);
			
			nextTicVal += xTicInterval;
		}
		nextTicVal = 0;
		for (int j = 0; j < numYTics; j++)
		{
			int ticY = (bounds.height - axisOffset) - (yTicCoordStep * j);
			
			g2.drawLine(yAxisXPos - ticSize, ticY, yAxisXPos + ticSize, ticY);
			
			g2.drawString(Double.toString(roundDouble(nextTicVal, 2)), yAxisXPos - textWidth, ticY);
			nextTicVal += yTicInterval;
		}
		
//		g2.drawLine(0, 428, 900, 428);
//		g2.drawLine(0, (bounds.y) + (int) ((bounds.height - axisOffset) - ((12000 / (maxFitness2 - minFitness2)) * (bounds.height - axisOffset))), 900, (bounds.y) + (int) ((bounds.height - axisOffset) - ((12000 / (maxFitness2 - minFitness2)) * (bounds.height - axisOffset))));
//		g2.drawLine(0, (bounds.y) + (int) ((bounds.height - axisOffset) - ((21000 / (maxFitness2 - minFitness2)) * (bounds.height - axisOffset))), 900, (bounds.y) + (int) ((bounds.height - axisOffset) - ((21000 / (maxFitness2 - minFitness2)) * (bounds.height - axisOffset))));
		
//		System.out.println("bounds.x " + bounds.x);
//		System.out.println("bounds.width " + bounds.width);
//		System.out.println("max " + maxFitness1);
//		System.out.println("min " + minFitness1);
//		System.out.println("f in range " + (maxFitness1 - minFitness1));
//		System.out.println("f in range " + (45555 - minFitness1) / (maxFitness1 - minFitness1));
//		System.out.println("calculation1 " + ((45555 - minFitness1) / (maxFitness1 - minFitness1)) * 850);
//		System.out.println("calculation2 " + ((45555 - minFitness1) / (maxFitness1 - minFitness1)) * (bounds.width - axisOffset));
		
		
		if (this.population != null)
		{
			for (Individual i : this.population)
			{
				if (i.rank == 0)
				{ // optimal
					g2.setColor(Color.blue);
				} else
				{
					g2.setColor(Color.gray);
				}

				// normalise fitnesses
				double n1 = (i.getFitness1() - minFitness1)
						/ (maxFitness1 - minFitness1);
				double n2 = (i.getFitness2() - minFitness2)
						/ (maxFitness2 - minFitness2);

				// System.out.println("A:" + i.getFitness1() + ":" + n1);
				// System.out.println("B:" + i.getFitness2() + ":" + n2);

//				int x = bounds.x + (int) (((i.getFitness1() - minFitness1) / (maxFitness1 - minFitness1)) * (bounds.width - axisOffset)) + axisOffset;
				int x = trimmedBounds.x + (int) (((i.getFitness1() - minFitness1) / (maxFitness1 - minFitness1)) * (trimmedBounds.width));
				
				int y = (bounds.y) + (int) ((bounds.height - axisOffset)
						- ((i.getFitness2() / (maxFitness2 - minFitness2))
								* (bounds.height - axisOffset)));

				g2.fillArc(x, y, 7, 7, 0, 360);
			} // end of loop over population
			list.setModel(setListModel(population));
		}
		
	}

	private ListModel<String> setListModel(Individual[] population)
	{
		String[] values = new String[population.length];
		for (int i = 0; i < population.length; i++)
			values[i] = String.format("%d %.4f", (i + 1), population[i].getFitness1());
		
		return new AbstractListModel<String>() {
			/** Default serial ID. */
			private static final long serialVersionUID = 1L;

			@Override
			public int getSize()
			{
				return values.length;
			}

			@Override
			public String getElementAt(int index)
			{
				return values[index];
			}
		};
	}
	
	private double roundDouble(double d, int decimalPlaces)
	{
		BigDecimal round = new BigDecimal(d).setScale(decimalPlaces,
				BigDecimal.ROUND_HALF_UP);
		Double doubleValue = new Double(round.doubleValue());
		return doubleValue;
	}
}