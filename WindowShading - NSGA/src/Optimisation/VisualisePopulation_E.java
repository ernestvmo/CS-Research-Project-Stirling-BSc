/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package Optimisation;

import java.awt.*;
import java.math.BigDecimal;
import javax.swing.JFrame;

/**
 *
 * @author cvaeib
 */
public class VisualisePopulation_E extends JFrame
{
	/** generated by eclipse */
	private static final long serialVersionUID = 7605105046723619314L;

//	public static void main(String[] args)
//	{
//		 VisualisePopulation_E f = new VisualisePopulation_E();
//		 f.updatePopulation(null);
//	}

	private boolean fixedMinMax;
	private double minFitness1;
	private double maxFitness1;
	private double minFitness2;
	private double maxFitness2;
	@SuppressWarnings("unused")
	private int pointWidth;
	@SuppressWarnings("unused")
	private int pointHeight;
	private static final double POINT_SIZE_AS_FRACTION_OF_WINDOW_SIZE = 0.01;
	private Individual[] population;

	public VisualisePopulation_E()
	{
		this(0, 1, 0, 1);
		this.fixedMinMax = false;
	}

	public VisualisePopulation_E(double minFitness1, double maxFitness1,
			double minFitness2, double maxFitness2)
	{
		this.fixedMinMax = true;
		this.minFitness1 = minFitness1;
		this.maxFitness1 = maxFitness1;
		this.minFitness2 = minFitness2;
		this.maxFitness2 = maxFitness2;
		this.setTitle("Visualise Population");
		this.setSize(900, 650);
		this.setVisible(true);
		this.population = null;
		this.setDefaultCloseOperation(EXIT_ON_CLOSE);
		this.setResizable(false);
	}

	public void setSize(int width, int height)
	{
		super.setSize(width, height);
		this.pointWidth = Math.max(1,
				(int) (width * POINT_SIZE_AS_FRACTION_OF_WINDOW_SIZE));
		this.pointHeight = Math.max(1,
				(int) (height * POINT_SIZE_AS_FRACTION_OF_WINDOW_SIZE));
	}

	public void updatePopulation(Individual[] pop)
	{
		if (!fixedMinMax)
		{
System.out.println("HERE");
			double min1 = Double.POSITIVE_INFINITY;
			double min2 = Double.POSITIVE_INFINITY;
			double max1 = Double.NEGATIVE_INFINITY;
			double max2 = Double.NEGATIVE_INFINITY;
			
//			min1 = 40000;
//			max1 = 48000;
			
			for (Individual i : pop)
			{
				if (i.getFitness1() < min1)
				{
					min1 = i.getFitness1();
				} 
				if (i.getFitness1() > max1)
				{
					max1 = i.getFitness1();
				}
			}
			
			min2 = 12000;
			max2 = 42000;

			// add a bit of padding
			double pad1 = (max1 - min1) * 0.2;
			double pad2 = (max2 - min2) * 0.2;

			this.minFitness1 = min1 - pad1;
			this.maxFitness1 = max1 + pad1;
			this.minFitness2 = min2 - pad2;
			this.maxFitness2 = max2 + pad2;
		}

		this.population = pop;
		// this.invalidate();
		// this.validate();
		this.repaint();
	}

	public void paint(Graphics g)
	{
		Graphics2D g2 = (Graphics2D) g;
		g2.setColor(Color.white);
		Rectangle bounds = this.getBounds();// g2.getClipBounds();
		bounds.setLocation(0, 0); // okay, we don't want to include the window's
									// coords for internal drawing!
		g2.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);

		// draw axes
		int axisOffset = 50;
		g2.setColor(Color.gray);
		int xAxisYPos = bounds.y + (bounds.height - axisOffset);
		int yAxisXPos = bounds.x + axisOffset;
		g2.drawLine(bounds.x, xAxisYPos, bounds.x + bounds.width, xAxisYPos); // x-axis
		g2.drawLine(yAxisXPos, bounds.y, yAxisXPos, bounds.height); // y-axis

		// trim the bounds to omit the axes (y coord is same as that's at top of
		// window)
		
		// add tic marks
		int textHeight = 20;
		int textWidth = 40;

		// points on axes (tics)
		int numXTics = 10;
		int numYTics = 10;
		int ticSize = 3;
		// NB- after this we pretend there is an extra tic at the extremes of
		// each of the axes, but don't show it as it'd be clipped
		
		double xTicInterval = (maxFitness1 - minFitness1) / (numXTics);
//		System.out.println("xTicInterval "  + xTicInterval);
		
//		System.out.println(maxFitness2 + "  " + minFitness2);
		
		double yTicInterval = (maxFitness2 - minFitness2) / (numYTics);
//		System.out.println("yTicInterval ss "  + yTicInterval);
		
		int xTicCoordStep = (bounds.width ) / (numXTics);
		int yTicCoordStep = (bounds.height - axisOffset) / (numYTics);
		
//		System.out.println(yTicCoordStep);

		double nextTicVal = minFitness1;
		for (int j = 0; j < numXTics; j++)
		{
			int ticX = (bounds.x + axisOffset) + (xTicCoordStep * j);
			
			g2.drawLine(ticX, xAxisYPos + ticSize, ticX, xAxisYPos - ticSize);
			
			g2.drawString(Double.toString(roundDouble(nextTicVal, 2)), ticX, xAxisYPos + textHeight);
			
			nextTicVal += xTicInterval;
		}
		nextTicVal = 0;
		for (int j = 0; j < numYTics; j++)
		{
			int ticY = (bounds.height - axisOffset) - (yTicCoordStep * j);
			
			g2.drawLine(yAxisXPos - ticSize, ticY, yAxisXPos + ticSize, ticY);
			
			g2.drawString(Double.toString(roundDouble(nextTicVal, 2)), yAxisXPos - textWidth, ticY);
			nextTicVal += yTicInterval;
		}
		
//		g2.drawLine(0, 428, 900, 428);
//		g2.drawLine(0, (bounds.y) + (int) ((bounds.height - axisOffset) - ((12000 / (maxFitness2 - minFitness2)) * (bounds.height - axisOffset))), 900, (bounds.y) + (int) ((bounds.height - axisOffset) - ((12000 / (maxFitness2 - minFitness2)) * (bounds.height - axisOffset))));
//		g2.drawLine(0, (bounds.y) + (int) ((bounds.height - axisOffset) - ((21000 / (maxFitness2 - minFitness2)) * (bounds.height - axisOffset))), 900, (bounds.y) + (int) ((bounds.height - axisOffset) - ((21000 / (maxFitness2 - minFitness2)) * (bounds.height - axisOffset))));
		
//		System.out.println("bounds.x " + bounds.x);
//		System.out.println("bounds.width " + bounds.width);
//		System.out.println("max " + maxFitness1);
//		System.out.println("min " + minFitness1);
//		System.out.println("f in range " + (maxFitness1 - minFitness1));
//		System.out.println("f in range " + (45555 - minFitness1) / (maxFitness1 - minFitness1));
//		System.out.println("calculation1 " + ((45555 - minFitness1) / (maxFitness1 - minFitness1)) * 850);
//		System.out.println("calculation2 " + ((45555 - minFitness1) / (maxFitness1 - minFitness1)) * (bounds.width - axisOffset));
		
		
		if (this.population != null)
		{
			for (Individual i : this.population)
			{
				if (i.rank == 0)
				{ // optimal
					g2.setColor(Color.blue);
				} else
				{
					g2.setColor(Color.gray);
				}

				// normalise fitnesses
				double n1 = (i.getFitness1() - minFitness1)
						/ (maxFitness1 - minFitness1);
				double n2 = (i.getFitness2() - minFitness2)
						/ (maxFitness2 - minFitness2);

				// System.out.println("A:" + i.getFitness1() + ":" + n1);
				// System.out.println("B:" + i.getFitness2() + ":" + n2);

				int x = bounds.x + (int) (((i.getFitness1() - minFitness1) / (maxFitness1 - minFitness1)) * (bounds.width - axisOffset)) + axisOffset;
				
				int y = (bounds.y) + (int) ((bounds.height - axisOffset)
						- ((i.getFitness2() / (maxFitness2 - minFitness2))
								* (bounds.height - axisOffset)));

				g2.fillArc(x, y, 7, 7, 0, 360);
			} // end of loop over population
		}
	}

	private double roundDouble(double d, int decimalPlaces)
	{
		BigDecimal round = new BigDecimal(d).setScale(decimalPlaces,
				BigDecimal.ROUND_HALF_UP);
		Double doubleValue = new Double(round.doubleValue());
		return doubleValue;
	}
}