/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package Optimisation;

import java.awt.*;
import java.math.BigDecimal;
import javax.swing.JFrame;

/**
 *
 * @author cvaeib
 */
public class VisualisePopulation extends JFrame
{
	/** generated by eclipse */
	private static final long serialVersionUID = 7605105046723619314L;

	public static void main(String[] args)
	{
		// VisualisePopulation f = new VisualisePopulation(0,1);
	}

	private boolean fixedMinMax;
	private double minFitness1;
	private double maxFitness1;
	private double minFitness2;
	private double maxFitness2;
	@SuppressWarnings("unused")
	private int pointWidth;
	@SuppressWarnings("unused")
	private int pointHeight;
	private static final double POINT_SIZE_AS_FRACTION_OF_WINDOW_SIZE = 0.01;
	private Individual[] population;

	public VisualisePopulation()
	{
		this(0, 1, 0, 1);
		this.fixedMinMax = false;
	}

	public VisualisePopulation(double minFitness1, double maxFitness1,
			double minFitness2, double maxFitness2)
	{
		this.fixedMinMax = true;
		this.minFitness1 = minFitness1;
		this.maxFitness1 = maxFitness1;
		this.minFitness2 = minFitness2;
		this.maxFitness2 = maxFitness2;
		this.setTitle("Visualise Population");
		this.setSize(400, 400);
		this.setVisible(true);
		this.population = null;
		this.setDefaultCloseOperation(EXIT_ON_CLOSE);
	}

	public void setSize(int width, int height)
	{
		super.setSize(width, height);
		this.pointWidth = Math.max(1,
				(int) (width * POINT_SIZE_AS_FRACTION_OF_WINDOW_SIZE));
		this.pointHeight = Math.max(1,
				(int) (height * POINT_SIZE_AS_FRACTION_OF_WINDOW_SIZE));
	}

	public void updatePopulation(Individual[] pop)
	{
		if (!fixedMinMax)
		{
			double min1 = Double.POSITIVE_INFINITY;
			double min2 = Double.POSITIVE_INFINITY;
			double max1 = Double.NEGATIVE_INFINITY;
			double max2 = Double.NEGATIVE_INFINITY;
			for (Individual individual : pop)
			{
				if (individual.getFitness1() < min1)
				{
					min1 = individual.getFitness1();
				} else if (individual.getFitness1() > max1)
				{
					max1 = individual.getFitness1();
				}
				if (individual.getFitness2() < min2)
				{
					min2 = individual.getFitness2();
				} else if (individual.getFitness2() > max2)
				{
					max2 = individual.getFitness2();
				}
			}

			// add a bit of padding
			double pad1 = (max1 - min1) * 0.2;
			double pad2 = (max2 - min2) * 0.2;

			this.minFitness1 = min1 - pad1;
			this.minFitness2 = min2 - pad2;
			this.maxFitness1 = max1 + pad1;
			this.maxFitness2 = max2 + pad2;
		}

		this.population = pop;
		// this.invalidate();
		// this.validate();
		this.repaint();
	}

	public void paint(Graphics g)
	{
		Graphics2D g2 = (Graphics2D) g;
		g2.setColor(Color.white);
		Rectangle bounds = this.getBounds();// g2.getClipBounds();
		bounds.setLocation(0, 0); // okay, we don't want to include the window's
									// coords for internal drawing!
		g2.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);

		// draw axes
		int axisOffset = 60;
		g2.setColor(Color.gray);
		int xAxisYPos = bounds.y + (bounds.height - axisOffset);
		int yAxisXPos = bounds.x + axisOffset;
		g2.drawLine(bounds.x, xAxisYPos, bounds.x + bounds.width, xAxisYPos); // x-axis
		g2.drawLine(yAxisXPos, bounds.y, yAxisXPos, bounds.height); // y-axis

		// trim the bounds to omit the axes (y coord is same as that's at top of
		// window)
		Rectangle trimmedBounds = new Rectangle(bounds.x + axisOffset, bounds.y,
				bounds.width - axisOffset, bounds.height - axisOffset);

		// add tic marks
		int textHeight = 20;
		int textWidth = 40;
		@SuppressWarnings("unused")
		int upperOffset = 30; // height of title bar - isn't "bounds" supposed
								// to account for this?
		// g2.drawString(Double.toString(minFitness1), bounds.x + axisOffset,
		// textHeight + bounds.y + (bounds.height - axisOffset));
		// g2.drawString(Double.toString(maxFitness1), bounds.x + bounds.width -
		// textWidth, textHeight + bounds.y + (bounds.height - axisOffset));
		// g2.drawString(Double.toString(minFitness2), bounds.x + axisOffset -
		// textWidth, bounds.y + (bounds.height - axisOffset));
		// g2.drawString(Double.toString(maxFitness2), bounds.x + axisOffset -
		// textWidth, bounds.y + textHeight + upperOffset);

		// points on axes (tics)
		int numXTics = 5;
		int numYTics = 5;
		int ticSize = 3;
		// NB- after this we pretend there is an extra tic at the extremes of
		// each of the axes, but don't show it as it'd be clipped
		double xTicInterval = (maxFitness1 - minFitness1) / (numXTics);
		double yTicInterval = (maxFitness2 - minFitness2) / (numYTics);
		int xTicCoordStep = trimmedBounds.width / (numXTics);
		int yTicCoordStep = trimmedBounds.height / (numYTics);
		double curFit = minFitness1 + xTicInterval;
		for (int i = 0; i < numXTics; i++)
		{
			int ticX = trimmedBounds.x + (xTicCoordStep * i);

			// the tic
			g2.drawLine(ticX, xAxisYPos + ticSize, ticX, xAxisYPos);

			// the text
			g2.drawString(Double.toString(roundDouble(curFit, 2)), ticX,
					xAxisYPos + textHeight);
			curFit += xTicInterval;
		}
		curFit = minFitness2 + yTicInterval;
		for (int i = 0; i < numYTics; i++)
		{
			int ticY = trimmedBounds.height - (yTicCoordStep * i);

			// the tic
			g2.drawLine(yAxisXPos - ticSize, ticY, yAxisXPos, ticY);

			// the text
			g2.drawString(Double.toString(roundDouble(curFit, 2)),
					yAxisXPos - textWidth, ticY);
			curFit += xTicInterval;
		}

		if (this.population != null)
		{
			for (Individual i : this.population)
			{
				if (i.rank == 0)
				{ // optimal
					g2.setColor(Color.blue);
				} else
				{
					g2.setColor(Color.gray);
				}

				// normalise fitnesses
				double n1 = (i.getFitness1() - minFitness1)
						/ (maxFitness1 - minFitness1);
				double n2 = (i.getFitness2() - minFitness2)
						/ (maxFitness2 - minFitness2);

				// System.out.println("A:" + i.getFitness1() + ":" + n1);
				// System.out.println("B:" + i.getFitness2() + ":" + n2);

				int x = trimmedBounds.x + (int) (trimmedBounds.width * n1);
				int y = trimmedBounds.y + trimmedBounds.height
						- (int) (trimmedBounds.height * n2);

				g2.fillRect(x, y, 4, 4);
			} // end of loop over population
		}
	}

	private double roundDouble(double d, int decimalPlaces)
	{
		BigDecimal round = new BigDecimal(d).setScale(decimalPlaces,
				BigDecimal.ROUND_HALF_UP);
		Double doubleValue = new Double(round.doubleValue());
		return doubleValue;
	}
}